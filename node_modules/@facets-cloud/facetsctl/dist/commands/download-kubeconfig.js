"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const os = require("os");
const core_1 = require("@oclif/core");
const Listr = require("listr");
const configuration_1 = require("../utils/configuration");
const FacetsAPI = require("../services/facets-api");
const errors_1 = require("@oclif/core/lib/errors");
class DownloadKubeconfig extends core_1.Command {
    async run() {
        const { flags } = await this.parse(DownloadKubeconfig);
        let envId = flags["environment-id"] || "";
        const blueprint = flags["blueprint-name"] || "";
        const envName = flags["environment-name"] || "";
        if (!envId && !blueprint && !envName) {
            throw new errors_1.CLIError("Either environment id or blueprint and environment name are required!", { exit: 2 });
        }
        const tasks = new Listr([
            {
                title: "Checking user credentials",
                task: (ctx) => {
                    try {
                        const config = (0, configuration_1.readConfig)();
                        ctx.config = config;
                    }
                    catch (error) {
                        if (!error.message) {
                            error.message =
                                "Error while fetching user credentials! Make sure you are logged in before downloading the kubeconfig";
                        }
                        throw new errors_1.CLIError(error, { exit: 2 });
                    }
                },
            },
            {
                title: "Downloading kubeconfig",
                task: async (ctx) => {
                    var _a;
                    try {
                        const config = ctx.config;
                        const { flags } = await this.parse(DownloadKubeconfig);
                        let envName = flags["environment-name"] || "";
                        if (envId) {
                            const cluster = await FacetsAPI.getClusterById(config.ControlPlaneURL, config.Username, config.AccessToken, envId);
                            envName = (_a = cluster === null || cluster === void 0 ? void 0 : cluster.data) === null || _a === void 0 ? void 0 : _a.name;
                        }
                        else {
                            const clustersRes = await FacetsAPI.getAllClustersByStackName(config.ControlPlaneURL, config.Username, config.AccessToken, blueprint);
                            const clusters = clustersRes.data || [];
                            const cluster = clusters === null || clusters === void 0 ? void 0 : clusters.find((cluster) => { var _a; return ((_a = cluster === null || cluster === void 0 ? void 0 : cluster.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === (envName === null || envName === void 0 ? void 0 : envName.toLowerCase()); });
                            if (!cluster)
                                throw new Error("Environment not found!");
                            envId = cluster === null || cluster === void 0 ? void 0 : cluster.id;
                            envName = cluster === null || cluster === void 0 ? void 0 : cluster.name;
                        }
                        const kubeConfigFileContent = await FacetsAPI.getKubeConfigFileContent(config.ControlPlaneURL, config.Username, config.AccessToken, envId);
                        const tempFileName = `${envName}-kubeconfig`;
                        const downloadFolderPath = this.getDownloadFolderPath();
                        const destinationPath = this.getUniqueFilePath(downloadFolderPath, tempFileName);
                        fs.writeFile(destinationPath, kubeConfigFileContent.data, (error) => {
                            if (error) {
                                throw new errors_1.CLIError(error, { exit: 2 });
                                this.error(`Error saving file: ${error.message}`);
                            }
                            else {
                                this.log(`File downloaded to: ${destinationPath}`);
                            }
                        });
                    }
                    catch (error) {
                        if (!error.message) {
                            error.message = "Error while refreshing token!";
                        }
                        throw new errors_1.CLIError(error, { exit: 2 });
                    }
                },
            },
        ]);
        try {
            await tasks.run();
        }
        catch (error) {
            throw error;
        }
    }
    getDownloadFolderPath() {
        var _a, _b;
        const downloadFolderPath = (os === null || os === void 0 ? void 0 : os.platform()) === "win32" ? ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.USERPROFILE) || (os === null || os === void 0 ? void 0 : os.homedir()) : ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.HOME) || (os === null || os === void 0 ? void 0 : os.homedir());
        return path.join(downloadFolderPath, "Downloads");
    }
    getUniqueFilePath(folderPath, fileName) {
        let uniqueFileName = fileName;
        let filePath = path.join(folderPath, uniqueFileName);
        let count = 1;
        while (fs.existsSync(filePath)) {
            const fileExtension = path.extname(fileName);
            const baseName = path.basename(fileName, fileExtension);
            uniqueFileName = `${baseName} (${count})${fileExtension}`;
            filePath = path.join(folderPath, uniqueFileName);
            count++;
        }
        return filePath;
    }
}
exports.default = DownloadKubeconfig;
DownloadKubeconfig.description = "Download your kubeconfig file for an environment. Kubeconfig can be downloaded using either an environment id or a combination of blueprint name and environment name.";
DownloadKubeconfig.examples = ["<%= config.bin %> <%= command.id %>"];
DownloadKubeconfig.flags = {
    "environment-id": core_1.Flags.string({
        char: "e",
        description: "Environment id for downloading kubeconfig",
        exclusive: ["environment-name", "blueprint-name"],
    }),
    "environment-name": core_1.Flags.string({
        description: "Environment name for downloading kubeconfig",
        dependsOn: ["blueprint-name"],
        exclusive: ["environment-id"],
    }),
    "blueprint-name": core_1.Flags.string({
        description: "Blueprint name using which environment was launched",
        dependsOn: ["environment-name"],
        exclusive: ["environment-id"],
    }),
};
DownloadKubeconfig.args = [];
