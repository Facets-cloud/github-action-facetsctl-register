"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const configuration_1 = require("../utils/configuration");
const FacetsAPI = require("../services/facets-api");
const Listr = require("listr");
const errors_1 = require("@oclif/core/lib/errors");
var RegistrationTypes;
(function (RegistrationTypes) {
    RegistrationTypes["CLUSTER"] = "CLUSTER";
    RegistrationTypes["RELEASE_STREAM"] = "RELEASE_STREAM";
    RegistrationTypes["ENVIRONMENT"] = "ENVIRONMENT";
})(RegistrationTypes || (RegistrationTypes = {}));
class ArtifactRegister extends core_1.Command {
    constructor() {
        super(...arguments);
        this.showOriginalError = false;
        this.checkUserCredentials = (ctx) => {
            try {
                const config = (0, configuration_1.readConfig)();
                ctx.config = config;
            }
            catch (error) {
                if (!error.message) {
                    error.message =
                        "Error while fetching user credentials! Make sure you are logged in before pushing";
                }
                throw new errors_1.CLIError(error, { exit: 2 });
            }
        };
        this.registerArtifact = async (ctx) => {
            var _a, _b, _c, _d;
            try {
                const { flags } = await this.parse(ArtifactRegister);
                const config = ctx.config;
                const artifact = {
                    applicationName: flags.service,
                    artifactUri: flags["docker-image"],
                    artifactory: flags.registry || "default",
                    description: flags.description || "",
                    externalId: flags["external-id"] || "",
                    metadata: {
                        BRANCH_NAME: flags["git-ref"],
                    },
                    registrationType: flags["registration-type"],
                    stackName: flags["blueprint-name"],
                };
                await FacetsAPI.pushArtifactWithMetadata(config === null || config === void 0 ? void 0 : config.ControlPlaneURL, config === null || config === void 0 ? void 0 : config.Username, config === null || config === void 0 ? void 0 : config.AccessToken, artifact);
            }
            catch (error) {
                if (this.showOriginalError) {
                    throw new errors_1.CLIError(((_b = (_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.message) || error, { exit: 2 });
                }
                if (error.code === "ENOTFOUND") {
                    error.message = "Incorrect URL of Control Plane!";
                }
                if (error.code === "ERR_BAD_REQUEST") {
                    error.message = ((_d = (_c = error === null || error === void 0 ? void 0 : error.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.message) || "Command failed with ERR_BAD_REQUEST error";
                }
                throw new errors_1.CLIError(error, { exit: 2 });
            }
        };
    }
    async run() {
        const { flags } = await this.parse(ArtifactRegister);
        this.showOriginalError = flags.debug === "true";
        const tasks = new Listr([
            {
                title: "Checking user credentials",
                task: this.checkUserCredentials,
            },
            {
                title: "Registering artifact",
                task: this.registerArtifact,
            },
        ]);
        try {
            await tasks.run();
        }
        catch (error) {
            // Throwing the error prints a duplicate message from bin/run as well, however that is fine to go with
            throw error;
        }
    }
}
exports.default = ArtifactRegister;
ArtifactRegister.description = "Register already pushed images from external repository to facets control plane";
ArtifactRegister.examples = ["<%= config.bin %> <%= command.id %>"];
ArtifactRegister.flags = {
    "docker-image": core_1.Flags.string({
        char: "i",
        description: "docker image URL in the external registry",
        required: true,
    }),
    service: core_1.Flags.string({
        char: "s",
        description: "name of the CI integration for which the artifact needs to be registered",
        required: true,
    }),
    description: core_1.Flags.string({
        char: "d",
        description: "description of the build if any",
        required: false,
    }),
    "external-id": core_1.Flags.string({
        char: "e",
        description: "external identifier for artifact",
        required: true,
    }),
    registry: core_1.Flags.string({
        description: "artifactory where image will be pushed",
        required: false,
    }),
    "git-ref": core_1.Flags.string({
        description: "git ref provided in CI Rule",
        required: true,
    }),
    "registration-type": core_1.Flags.string({
        description: "mode of registration for CI integration",
        options: [RegistrationTypes === null || RegistrationTypes === void 0 ? void 0 : RegistrationTypes.ENVIRONMENT, RegistrationTypes.RELEASE_STREAM],
        required: false,
    }),
    "blueprint-name": core_1.Flags.string({
        description: "blueprint name in which CI Integration will be created if not present already",
        required: false,
    }),
    debug: core_1.Flags.string({
        description: "see original error message thrown",
        required: false,
        default: "false",
    }),
};
ArtifactRegister.args = [];
